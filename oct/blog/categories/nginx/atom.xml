<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Nginx | 小默的研究中心]]></title>
  <link href="http://wangxiaomo.github.com/blog/categories/nginx/atom.xml" rel="self"/>
  <link href="http://wangxiaomo.github.com/"/>
  <updated>2012-06-12T21:30:43+08:00</updated>
  <id>http://wangxiaomo.github.com/</id>
  <author>
    <name><![CDATA[wangxiaomo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[cgi.Fastcgi.PHP-fpm 介绍与比较]]></title>
    <link href="http://wangxiaomo.github.com/blog/2011/02/07/cgi.Fastcgi.PHP-fpm+%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%AF%94%E8%BE%83/"/>
    <updated>2011-02-07T06:29:00+08:00</updated>
    <id>http://wangxiaomo.github.com/blog/2011/02/07/cgi.Fastcgi.PHP-fpm 介绍与比较</id>
    <content type="html"><![CDATA[<p>一.cgi是伴随着并发请求不断fork的.所以在访问量小的时候问题不会体现出来.但是效率低.并发处理差.
二.fastcgi是常驻内存的.还支持分布式的运算,即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求.但是由于fastcgi同时开多个cgi进程常驻于内存.效率并不高.资源利用不合理.虽然略去了反复fork cgi的费时步骤.但还是不给力.
FastCGI的工作原理
1、Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module)
2、FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。
3、当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi
4、FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。</p>

<!--more-->


<p>FastCGI的不足
因为是多进程，所以比CGI多线程消耗更多的服务器内存，PHP-CGI解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。
Nginx 0.8.46+PHP 5.2.14(FastCGI)服务器在3万并发连接下，开启的10个Nginx进程消耗150M内存（15M<em>10=150M），开启的64个php-cgi进程消耗1280M内存（20M</em>64=1280M），加上系统自身消耗的内存，总共消耗不到2GB内存。如果服务器内存较小，完全可以只开启25个php-cgi进程，这样php-cgi消耗的总内存数才500M。
php-cgi是php自带的fastcgi管理器.</p>

<pre lang="bash">php-cgi -b 127.0.0.1:9000</pre>


<p>可以启动php-cgi程序.
PHP-CGI的不足
1、php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启
2、直接杀死php-cgi进程,php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题,守护进程会平滑从新生成新的子进程。）
三.php-fpm一个PHP FastCGI管理器.</p>

<pre lang="bash">/usr/local/php/sbin/php-fpm{start|stop|quit|restart|reload|logrotate}

--start 启动php的fastcgi进程
--stop 强制终止php的fastcgi进程
--quit 平滑终止php的fastcgi进程
--restart 重启php的fastcgi进程
--reload 重新平滑加载php的php.ini
--logrotate 重新启用log文件</pre>


<p>一般选择这种作为正式应用方案(修改nginx站点配置文件和php-fpm.conf)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx目录显示以及与PHP的交互]]></title>
    <link href="http://wangxiaomo.github.com/blog/2011/02/07/Nginx%E7%9B%AE%E5%BD%95%E6%98%BE%E7%A4%BA%E4%BB%A5%E5%8F%8A%E4%B8%8EPHP%E7%9A%84%E4%BA%A4%E4%BA%92/"/>
    <updated>2011-02-07T04:24:00+08:00</updated>
    <id>http://wangxiaomo.github.com/blog/2011/02/07/Nginx目录显示以及与PHP的交互</id>
    <content type="html"><![CDATA[<p>今天<a href="http://haizhu.info" target="_blank">毛泽小同学</a>在配置自己的vps的时候出了些问题.让我帮忙配置.虽然自己只用过nginx不到一星期.但是不好拒绝.那就着手干吧.
首先ssh登录到他的vps.速度不是一般的快啊.比那个opensalon的速度给力多了.许多人都花二三十块钱买了vps.为嘛.为的就是自由.不像我们这种在sae上停留的人.各种限制.唯一的好处.也就是速度了吧 .
下面说问题.
经过简单的测试.发现所有php页面无法访问.很明显是nginx与php的交互出了问题.
1.开启目录显示. 调试的时候不调目录显示感觉很不爽.
  在/etc/nginx/site-available/default下的站点配置中.Server{}节点中加如autoindex on;并把location /{}中的index行删去.
2.nginx与php-cgi的交互.nginx与apache不一样.apache目录下放置php.ini和php处理的相关model.就可以了.nginx是通过nginx进程讲请求传递给php-cgi进程.所以需要在配置文件中写明:
  location ~.*.php?$ {</p>

<pre><code>    include fastcgi_params;
    fastcgi_pass 127.0.0.1:9000;
    fastcgi_param 网页目录$fastcgi_script_name;
    #fastcgi_index index.php;
</code></pre>

<p>  }
  之后重启nginx.然后开启php-cgi进程. php-cgi -b 127.0.0.1:9000 -q.然后OK
  上述测试之后.发现他的问题了.:php-cgi没启动. 多么囧的问题.</p>
]]></content>
  </entry>
  
</feed>
