<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mongo | 小默的研究中心]]></title>
  <link href="http://wangxiaomo.github.com/blog/categories/mongo/atom.xml" rel="self"/>
  <link href="http://wangxiaomo.github.com/"/>
  <updated>2012-06-12T19:58:29+08:00</updated>
  <id>http://wangxiaomo.github.com/</id>
  <author>
    <name><![CDATA[wangxiaomo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mongo 聚合]]></title>
    <link href="http://wangxiaomo.github.com/blog/2012/06/04/Mongo+%E8%81%9A%E5%90%88/"/>
    <updated>2012-06-04T05:28:00+08:00</updated>
    <id>http://wangxiaomo.github.com/blog/2012/06/04/Mongo 聚合</id>
    <content type="html"><![CDATA[<p>1.count</p>

<pre lang="mongo">
>db.foo.count()
0
>db.foo.insert({x:1})
>db.foo.count()
1
>db.foo.count({x:1})
1
</pre>


<p>增加查询条件会使 count 变慢.</p>

<p>2.distinct</p>

<pre lang="mongo">
>db.runCommand({distinct:"users", key:"username"})
</pre>


<p>distinct 的 value 是 collection name. 而 key 是 distinct 的字段.</p>

<p>3.group group 会根据分组所依据的 key 将 document 分成若干组.然后通过聚合每一组内的 document 产生一个文档结果.
先把集合按天分组,然后取出每一组内的最新时间戳的文档.</p>

<pre lang="mongo">
>db.runCommand({group:{
    ns:"stocks",      # 指定要分组的集合.
    key:"day",        # 指定分组依据的 key
    initial:{time:0}, # reduce 的初始化
    $reduce:function(doc, prev){
        if(doc.time>prev.time){
            prev.price = doc.price;
            prev.time = doc.time;
        }
    }}})
</pre>


<p>使用完成器.
finalizer 用以精简从数据库传到用户的数据.
举例:每篇文章有多个 tag,现在找出每天最热门的 tag.</p>

<pre lang="mongo">
>db.posts.group({
    key:{tags:true},
    initial:{tags:{}},
    $reduce:function(doc, prev){
        for(i in doc.tags){
            if(doc.tags[i] in prev.tags){
                 prev.tags[doc.tags[i]]++;
            }else{
                 prev.tags[doc.tags[i]] = 1;
            }
        }
    }})
</pre>


<p>返回的结果是这样的.</p>

<pre lang="mongo">
[
  {day:2010/01/12, tags:{nosql:4,winter:10,sledding:2}},
  {day:2010/01/13, tags:{soda:4}},
  {day:2010/01/14, tags:{python:5, c:6}}
]
</pre>


<p>现在我们加入 finalizer.</p>

<pre lang="mongo">
>db.funCommand({group:{
    ns:'posts',
    key:{tags:true},
    initial:{tags:{}},
    $reduce:function(doc, prev){
       for(i in doc.tags){
            if(doc.tags[i] in prev.tags){
                 prev.tags[doc.tags[i]]++;
            }else{
                 prev.tags[doc.tags[i]] = 1;
            }
        }
    },
    finalize:function(prev){
        var mostPopular = 0;
        for(i in prev.tags){
            if(prev.tags[i]>mostPopular){
                prev.tag = i;
                mostPopular = prev.tags[i];
            }
        }
        delete prev.tags
    }}})
</pre>


<p>好了.现在仅返回所希望的结果了.</p>

<p>MapReduce MapReduce 能做 count,distinct,group 能做的所有事情.MapReduce 最开始是映射( map ),将操作映射到集合中的每个文档.这个操作要么是无作为,要么产生一些键和 X 个值.然后就是中间环节,称作洗牌( shuffle ),按照键分组,并将产生的键值组成列表放到对应的键中.化简( reduce )则把列表中的值化简称为一个单值,然后返回.
使用 MapReduce 的代价就是速度.group 不是很快, MapReduce 更慢.绝不要把 MapReduce 用在实时环境中,要作为后台任务来运行 MapReduce.
例1.找出集合中所有键.</p>

<pre lang="mongo">
>map = function(){
    for(var key in this){
        emit(key, {count:1});
    }};
</pre>


<p>这样就有了 n 个 {count:1} 的文档.每一个都与集合中的一个键相关.它会传递给 reduce 函数.reduce 函数有两个参数,第一个是 emit 的第一个参数,就是 key.第二个参数是一个数组.有一个或多个对应于键的值组成.</p>

<pre lang="mongo">
>reduce = function(key, emits){
    total = 0;
    for(var i in emits){
        total += emits[i].count;
    }
    return {count:total};
 }
>mr = db.runCommand({mapreduce:'foo', map:map, reduce:reduce})
</pre>


<p>之后结果会被放在一个临时集合中.在 MapReduce 连接关闭后会自动删除.</p>

<pre lang="mongo">
>db[mr.result].find()
</pre>


<p>查询结果.</p>

<p>例2.网页分类.
假设有个网站.人们可以提交其他网页的链接.然后附上链接的标签.现在用 MapReduce 找出最热门的标签.</p>

<pre lang="mongo">
map = function(){
    for(var i in this.tags){
        var recency = 1/(new Date()-this.date);
        var scroe = recency*this.score;
        emit(this.tags[i],{urls:[this.url], score:score});
};
reduce = function(key, emits){
    var total = {urls:[], score:0};
    for(var i in emits){
        emits[i].urls.forEach(function(url){
            total.urls.push(url);
        }
        total.score += emits[i].score;
    }
    return total;
};
</pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mongo Shell]]></title>
    <link href="http://wangxiaomo.github.com/blog/2012/06/02/Mongo+Shell/"/>
    <updated>2012-06-02T08:02:00+08:00</updated>
    <id>http://wangxiaomo.github.com/blog/2012/06/02/Mongo Shell</id>
    <content type="html"><![CDATA[<p>show dbs 显示数据库列表
show collections 显示当前数据库中的集合
show users 显示用户</p>

<br />


<p>use <db_name> 切换数据库.
db.help() 数据库帮助
db.foo.help() 集合帮助</p>

<br/>


<p>db.dropDatabase() 删除当前的数据库
db.cloneDatabase("127.0.0.1")  从目标克隆数据库.
db.version() 查看 mongo 版本
db.getMongo() 查看当前 db 的链接机器地址</p>
]]></content>
  </entry>
  
</feed>
