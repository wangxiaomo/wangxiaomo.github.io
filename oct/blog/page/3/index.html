
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>小默的研究中心</title>
  <meta name="author" content="wangxiaomo">

  
  <meta name="description" content="最近没事干。学习下 AnyEvent。
AnyEvent::Intro
AnyEvent 是一个基于事件编程的框架。大多数框架与其他框架之间是互斥的，而 AnyEvent 却是在事件顶层的一个 layer，就像 DBI 一样的驱动。
什么是基于事件的编程？
一个简单的需求。 $| = 1; &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://wangxiaomo.github.com/blog/page/3/">
  <link href="/oct/favicon.png" rel="icon">
  <link href="/oct/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/oct/javascripts/modernizr-2.0.js"></script>
  <script src="/oct/javascripts/ender.js"></script>
  <script src="/oct/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/oct/blog/atom.xml" rel="alternate" title="小默的研究中心" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/oct/">小默的研究中心</a></h1>
  
    <h2>Perl | PHP | Python...技术宅.微博控</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/oct/blog/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:wangxiaomo.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/oct/">Blog</a></li>
  <li><a href="/oct/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/oct/blog/2012/03/07/Perl+AnyEvent%3A%3AIntro+%26%26+AnyEvent/">Perl AnyEvent::Intro && AnyEvent</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-07T12:20:00+08:00" pubdate data-updated="true">Mar 7<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近没事干。学习下 AnyEvent。
<span class="label label important">AnyEvent::Intro</span>
AnyEvent 是一个基于事件编程的框架。大多数框架与其他框架之间是互斥的，而 AnyEvent 却是在事件顶层的一个 layer，就像 DBI 一样的驱动。
什么是基于事件的编程？
一个简单的需求。</p>

<pre lang="perl">
$| = 1;
print "enter your name> ";
my $name = <STDIN>;
</pre>


<p>基于事件编程中我们通过 callback 来实现：</p>

<pre lang="perl">
use AnyEvent;

$| = 1;
print "enter your name> ";
my $name;

my $wait_for_input = AnyEvent->io(
    fh    =>  \*STDIN, # 所要检查的句柄
    poll  =>  "r",     # 哪个事件。 r => read 事件。
    cb    =>  sub { $name = <STDIN>; },
);

# 其他操作
</pre>


<p>这样写最重要的好处是在等待输入的同时你可以做其他的业务，并不会因为 I/O 操作而阻塞。
我们通过 AnyEvent->io 来创建了一个 watcher 来观察事件的发生并做出相应的响应。之后我们需要启动 event loop 来使它正常工作。在 AnyEvent 中通过状态变量来控制 event loop。</p>

<pre lang="perl">
use AnyEvent;

$| = 1;
print "enter your name> ";

my $name;
my $name_ready     = AnyEvent->condvar;
my $wait_for_input = AnyEvent->io(
    fh     =>    \*STDIN,
    poll   =>    'r',
    cb     =>    sub { $name = <STDIN> and $name_ready->send }
);

# do something else
# ....

# now wait until the name is available
$name_ready->recv;
undef $wait_for_input;

print "your name is $name\n";
</pre>


<p>上面的代码中我们通过 AnyEvent->condvar 来创建了一个状态变量。然后我们又创建了一个 watcher，但是在 callback 中我们发送了 $name_ready 状态，所以 event loop 停止。
我们也可以这样做：</p>

<pre lang="perl">
use AnyEvent;

$| = 1;
print "enter your name> ";

my $name_ready     = AnyEvent->condvar;
my $wait_for_input = AnyEvent->io(
       fh    =>   \*STDIN,
       cb    =>   sub { $name_ready->send( scalar <STDIN> ); },
);

# do something else
# ...
# now wait and fetch the name
my $name = $name_ready->recv;
undef $wait_for_input;

print "your name is $name\n";
</pre>


<p>上面是对句柄简单的操作。下面是一个 timer 的例子。</p>

<pre lang="perl">
use AnyEvent;

my $cv = AnyEvent->condvar;
my $e  = AnyEvent->timer(
    after   =>  1.5,
    cb      =>  sub { $cv->send },
);

$cv->recv;
</pre>


<p>AnyEvent 不只能对句柄、timer 进行操作，还可以对 system signal、child and idle 进行事件编程。
下面是一些与网络编程相关的模块：AnyEvent::DNS、AnyEvent::Handle、AnyEvent::Socket。
下面我们通过实现一个非阻塞的 finger server 来学习。</p>

<pre lang="perl">
use AnyEvent;
use AnyEvent::Socket;

sub finger($$) {
    my ($user, $host) = @_;
    my $cv = AnyEvent->condvar;

    tcp_connect $host, "finger", sub {
         my $fh = @_
             or return $cv->send;
         syswrite $fh, "$user\015\012";

         my $response;
         my $read_watcher;$read_watcher = AnyEvent->io(
             fh    =>  $fh,
             poll  =>  'r',
             cb    =>  sub {
                 my $len = sysread $fh, $response, 1024, length $response;
                 if ($len>0) {
                      undef $read_watcher;
                      $cv->send $response;
                 }
             },
         );
     };

     $cv;
}
</pre>


<p>之前使用过 twisted ，而且也较深入的研究过。所以理解起来不是很费劲。
具体的，还是要根据应用来学习。。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/oct/blog/2012/03/07/3%E6%9C%88%E6%88%963%E6%9C%88%E5%88%9D%EF%BC%9F+%E6%84%9F%E6%85%A8%E3%80%82/">3月或3月初？ 感慨。</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-07T08:12:00+08:00" pubdate data-updated="true">Mar 7<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>首先。我不是一个喜爱文字的人，但是偶尔也通过文字来表达自己内心的想法。有些东西不想让别人看到，也不知道该写在哪里。乱七八糟的思绪就随便写写吧。
之前的自己也算是一个 night programmer。可自己唯一的缺点就是老以各种事情来当作借口，推脱自己的计划。
LRQ 考研失败了，虽然劝她要坚强，可是自己却也从心里觉得这样的劝解是那么的无力。
还有 2 个月就应该着手找工作了吧。实验室还有着项目，虽然心底是不想做的，可这么多年也熬过来了。
哎。很多东西想说，却又不想展开。
真的。需要尽力而为了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/oct/blog/2012/02/28/2%E6%9C%88%E6%80%BB%E7%BB%93%E3%80%82%E4%BB%A5%E5%8F%8A+Perl+Sina+SDK+OAuth+%E8%AE%A4%E8%AF%81%E9%83%A8%E5%88%86%E7%9A%84%E5%8F%91%E5%B8%83/">2月总结。以及 Perl Sina SDK OAuth 认证部分的发布</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-28T06:28:00+08:00" pubdate data-updated="true">Feb 28<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>假期由于不能上网，所以博客一直没有更新，中间确实偷懒了很长时间，不过自己也确实做了些东西。
1.由于对 pod 越来越喜爱，所以希望找一个能够方便阅读编辑 pod 的软件，不过没有找到。所以用 java 写了 podviewer 。之后会逐步完善它。
2.趁着对 Moose::Manual 翻译的感觉，继续翻译了 perldoc perltut 系列。通过这个过程了解到了很多原先不知道的小知识。这个也需要后期进一步完善一下。
3.在 PAUSE 申请了开发者，并且申请到了 Wrap::Simple 模块。
4.写了 perldoc.pl 来对官方的 perldoc 进行改进。
5.python 写了一堆微薄应用。这个不是什么难点，不过确实是假期摆在我面前的一个比较大的需求。</p>

<p>然后就是补考，开学。忙着实验室的事情，也没有时间干其他的。不过鉴于假期一直在用 python weibo oauth1 sdk，感觉用着很别扭。因为要从 perl 转到 python。所以决定要写一个 perl sina oauth1 sdk。</p>

<p>本来想按着 php liboauth 的思路来写，不过最终还是按着 python sina sdk 的思路来写的。</p>

<p>下面是 oauth 认证部分。 api 绑定的话会通过 AUTOLOAD 来实现。最近实验室的事情多。先放置下。。</p>

<pre lang="perl">
=pod

=encoding UTF-8

=head1 NAME

Weibo - Sina Weibo OAuth 1.0a Wrapper

=cut

package Weibo;

use strict 'vars';
use warnings;

=head1 VERSION

VERSION - 1.0

=cut

our $VERSION = "1.0";
$VERSION = eval { $VERSION };

=head1 REQUIRE

LWP::UserAgent HTTP::Request Digest::HMAC_SHA1

=cut

sub BEGIN {
    require LWP::UserAgent;
    require HTTP::Request;
    require Digest::HMAC_SHA1;
}

=head1 NAMESPACES

模块中包含如下 namespaces 用来简化 OAuth 过程。

=over 4

=item OAuthToken

OAuthToken 用来解析网页返回的 token 字符串。

    my $resp  = LWP::UserAgent->new()->request('GET', 'http://baidu.com');
    my $token = OAuthToken::from_string($resp->{_content});

=cut

package OAuthToken;

sub new {
    my $class = 'OAuthToken';
    my ($token, $secret) = @_;
    my $self  = {
        key   =>    $token,
        secret=>    $secret,
    };
    bless $self, $class;
}

sub from_string {
    my $str    = shift;
    use CGI;
    my $params = CGI->new($str);
    my ($token, $secret) = (
        $params->param('oauth_token'),
        $params->param('oauth_token_secret'),
    );
    my $self   = &new($token, $secret);
    return $self;
}

sub token {
    my $self = shift;
    return $self->{key};
}

sub secret {
    my $self = shift;
    return $self->{secret};
}

=item OAuthConsumer

OAuthConsumer 用来实例化 token 对。

    my $consumer = OAuthConsumer->new(
        {consumer_token=>'xxx',consumer_secret=>'xxx'}
    );

=cut

#---------------------------------------------------
package OAuthConsumer;

sub new {
    my $class = shift;
    my $token = shift;
    bless $token, $class;
}

sub token {
    my $self = shift;
    return $self->{consumer_token};
}

sub secret {
    my $self = shift;
    return $self->{consumer_secret};
}
#---------------------------------------------------

=item OAuthSignatureMethod_HMAC_SHA1

OAuthSignatureMethod_HMAC_SHA1 用来初始化 HMAC_SHA1 方法。这里用到了 Digest::HMAC_SHA1 包和 MIME::Base64 包。
后期通过继承 OAuthSignatureMethod 来拓展其他加密算法。

    my $signature = OAuthSignatureMethod_HMAC_SHA1->new();

=cut

#-------------------------------------------------------------
package OAuthSignatureMethod;
my $not_implemented = "NotImplementedError";
sub get_name { $not_implemented }
sub build_signature_base_string { $not_implemented }
sub build_signature { $not_implemented }
sub check_signature {
    my $self = shift;
    my ($oauth_request, $consumer, $token, $signature) = @_;
    my $build = $self->build_signature(
                    $oauth_request,
                    $consumer,
                    $token,
    );
    return $build == $signature;
}

package OAuthSignatureMethod_HMAC_SHA1;
use base qw/OAuthSignatureMethod/;
sub escape {
    use URI::Escape;
    return uri_escape($_[0]);
}
sub new { 
    my $class = shift;
    my $self  = {};
    bless $self, $class;
}
sub get_name { "HMAC-SHA1" }
sub build_signature_base_string {
    my $self = shift;
    my ($oauth_request, $consumer, $token) = @_;
    
    my @sig = (
        escape($oauth_request->get_normalized_http_method),
        escape($oauth_request->get_normalized_http_url),
        escape($oauth_request->get_normalized_parameters),
    );
    my $key = escape($consumer->secret) . "&";
    $key = $key . escape($token->secret) if defined $token;
    
    my $raw = join('&', @sig);
    return [$key, $raw];
}
sub build_signature {
    my $self = shift;
    my $ref  = $self->build_signature_base_string(@_);
    
    use Digest::HMAC_SHA1;
    use MIME::Base64;

    my $hmac = Digest::HMAC_SHA1->new($ref->[0]);
    $hmac->add($ref->[1]);
    return encode_base64($hmac->digest, '');
}
#-----------------------------------------------------------------------

=item OAuthRequest

OAuthRequest 用来封装各种 OAuth 请求并生成相应的 header, url 来供进一步请求。

    my $req  = OAuthRequest::from_consumer_and_token(
        $self->{_consumer},$url);
    $req->sign_request(
        $self->{_signature},
        $self->{_consumer}
    );
    my $header = $req->to_header;

=cut

package OAuthRequest;
sub escape {
    use URI::Escape;
    return uri_escape(@_);
}
sub new {
    my $class = 'OAuthRequest';
    my ($http_method, $http_url, $parameters) = @_;
    my $self  = {
        http_method     =>  $http_method,
        http_url        =>  $http_url,
        parameters      =>  defined($parameters)?$parameters:{},
    };
    bless $self, $class;
}
sub from_consumer_and_token {
    my ($consumer, $http_url, $token, $pin) = @_;
    my $default  = {
        'oauth_consumer_key'    =>  $consumer->token,
        'oauth_timestamp'       =>  int(time),
        'oauth_nonce'           =>  int( rand(2**32)),
        'oauth_version'         =>  "1.0",
        #'oauth_timestamp'       =>  "1330225825",
        #'oauth_nonce'           =>  "79844044",
    };
    $default->{oauth_token}    = $token->token if defined $token;
    $default->{oauth_verifier} = $pin if defined $pin;
    my $self = &new('GET', $http_url);
    $self->{parameters} = $default;
    return $self;
}
sub from_token_and_callback {
    my ($token, $url, $callback)  = @_;
    my $parameters                = {};
    $parameters->{oauth_token}    = $token->token;
    $parameters->{oauth_callback} = $callback if defined $callback;
    my $self = &new('GET', $url, $parameters);
    return $self;
}
sub sign_request {
    my $self = shift;
    my ($sign_method, $consumer, $token) = @_;
    $self->{parameters}->{oauth_signature_method} = $sign_method->get_name();
    $self->{parameters}->{oauth_signature} = escape($sign_method->build_signature(
        $self, $consumer, $token));
}
sub to_header {
    my $self        = shift;
    my $auth_header = 'OAuth realm=""';
    if(not defined($self->{parameters}->{oauth_verifier})) {
    $auth_header = $auth_header . ", oauth_nonce=\""
                 . $self->{parameters}->{oauth_nonce} . "\", "
                 . "oauth_timestamp=\""
                 . $self->{parameters}->{oauth_timestamp} . "\", "
                 . "oauth_consumer_key=\""
                 . $self->{parameters}->{oauth_consumer_key} . "\", "
                 . "oauth_signature_method=\""
                 . $self->{parameters}->{oauth_signature_method} . "\", "
                 . "oauth_version=\""
                 . $self->{parameters}->{oauth_version} . "\", "
                 . "oauth_signature=\""
                 . $self->{parameters}->{oauth_signature} . "\"";
    } else {
    $auth_header = $auth_header . ", oauth_nonce=\""
                 . $self->{parameters}->{oauth_nonce} . "\", "
                 . "oauth_timestamp=\""
                 . $self->{parameters}->{oauth_timestamp} . "\", "
                 . "oauth_signature_method=\""
                 . $self->{parameters}->{oauth_signature_method} . "\", "
                 . "oauth_consumer_key=\""
                 . $self->{parameters}->{oauth_consumer_key} . "\", "
                 . "oauth_verifier=\""
                 . $self->{parameters}->{oauth_verifier} . "\", "
                 . "oauth_version=\""
                 . $self->{parameters}->{oauth_version} . "\", "
                 . "oauth_token=\""
                 . $self->{parameters}->{oauth_token} . "\", "
                 . "oauth_signature=\""
                 . $self->{parameters}->{oauth_signature} . "\"";   
    }
    return [
            'Authorization', $auth_header,
           ];
}
sub to_postdata {
    my $self   = shift;
    my %params = ();
    foreach my $k (keys %{$self->{parameters}}) {
        $params{escape($k)} = escape($self->{parameters}->{$k});
    }
    return join('&', map { $_ . "=" . $params{$_}}
                         keys %params);
}
sub to_url {
    my $self = shift;
    return $self->get_normalized_http_url . "?" . $self->to_postdata;
}
sub get_normalized_parameters {
    my $self = shift;
    delete $self->{parameters}->{oauth_signature}
        if exists $self->{parameters}->{oauth_signature};
    my %params = ();
    foreach my $k (keys $self->{parameters}) {
        $params{escape($k)} = escape($self->{parameters}->{$k});
    }
    my @keys = sort keys %params; 
    return join("&", map {$_ . "=" . $params{$_} } @keys);
}
sub get_normalized_http_method {
    my $self = shift;
    return uc $self->{http_method};
}
sub get_normalized_http_url {
    my $self = shift;
    return $self->{http_url};
}
#-----------------------------------------------------------------------

=item OAuthHandler

OAuthHandler 是整个 OAuth 过程中的主句柄。

    my $hdl = OAuthHandler({consumer_token=>'xx',consumer_secret=>'xx'});

=cut

package OAuthHandler;
my $base = "http://api.t.sina.com.cn/oauth/";
my $urls = {
    request_url     => $base . "request_token",
    auth_url        => $base . "authorize",
    access_url      => $base . "access_token",
};

sub new {
    my $class = shift;
    my $self  = {
        _consumer       =>  OAuthConsumer->new(@_),
        _sigmethod      =>  OAuthSignatureMethod_HMAC_SHA1->new(),
        request_token   =>  undef,
        access_token    =>  undef,
    };
    bless $self, $class;
}

sub get_request_token {
    my $self = shift; 
    my $url  = $urls->{request_url};
    my $req  = OAuthRequest::from_consumer_and_token(
        $self->{_consumer},$url);
    $req->sign_request(
        $self->{_sigmethod},
        $self->{_consumer}
    );
    my $header = $req->to_header;
    use LWP::UserAgent;
    use HTTP::Request;
    my $r = HTTP::Request->new(
        'GET',
        $url,
       $header
    );
    my $agent = LWP::UserAgent->new();
    my $resp  = $agent->request($r);
    return OAuthToken::from_string($resp->{_content});
}

sub get_authorization_url {
    my $self = shift;
    $self->{request_token} = $self->get_request_token;
    my $url  = $urls->{auth_url};
    my $req  = OAuthRequest::from_token_and_callback(
                 $self->{request_token},
                 $url
    );
    return $req->to_url;
}

sub get_access_token {
    my $self = shift;
    my $pin  = shift;
    my $url  = $urls->{access_url};
    my $req  = OAuthRequest::from_consumer_and_token(
                $self->{_consumer},
                $url,
                $self->{request_token},
                $pin
    );
    $req->sign_request(
        $self->{_sigmethod},
        $self->{_consumer},
        $self->{request_token}
    );
    use LWP::UserAgent;
    use HTTP::Request;
    my $r     = HTTP::Request->new(
                 'GET',
                 $url,
                 $req->to_header
    );
    my $agent = LWP::UserAgent->new();
    my $resp  = $agent->request($r);
    my $token = OAuthToken::from_string($resp->{_content});
    $self->{access_token} = $token;
    return $token;
}

sub set_access_token {
    my $self  = shift;
    my $token = shift;
    $self->{access_token} = $token;
}

=item API

Weibo API Handler

=cut

1;

=back

=head1 AUTHOR

xiaomo(wxm4ever@gmail.com)

=cut

#-------------------------------

package main;
my $consumer_token  = "xxxxxxxxxxxxxxxxx";
my $consumer_secret = "xxxxxxxxxxxxxxxxx";
my $access_token    = "xxxxxxxxxxxxxxxxx";
my $access_secret   = "xxxxxxxxxxxxxxxxx";

my $hdl = OAuthHandler->new({
    consumer_token  =>  $consumer_token,
    consumer_secret =>  $consumer_secret,
});
#print $hdl->get_authorization_url(),"\n";
#my $pin = <>;
#chomp $pin;
#print "PIN: $pin\n";
#$access_token = $hdl->get_access_token($pin);
my $token = OAuthToken->new($access_token, $access_secret);
$hdl->set_access_token($token);

__END__
</pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/oct/blog/2012/01/08/%5Bperldoc%5Dperlpod/">[Perldoc]perlpod</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-01-08T05:11:00+08:00" pubdate data-updated="true">Jan 8<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><pre lang="perl">

        *****************************************************
        *           GENERATED FILE, DO NOT EDIT             * 
        * THIS IS NO SOURCE FILE, BUT RESULT OF COMPILATION *
        *****************************************************

This file was generated by po4a(7). Do not store it (in VCS, for example),
but store the PO file used as source file by po4a-translate. 

In fact, consider this as a binary, and the PO file as a regular .c file:
If the PO get lost, keeping this translation up-to-date will be harder.

=encoding utf8

=for comment This document is in Pod format.  To read this, use a Pod formatter,
like "perldoc perlpod".

=head1 NAME X<POD> X<plain old documentation>

perlpod - POD 介绍

=head1 DESCRIPTION

Pod 是一种方便为 Perl、Perl 程序、Perl
模块书写文档的一种标记型语言。

它能很方便的转化为 text，HTML，man pages 等其它格式。

Pod 有三个基本类型的段落组成：L<ordinary|/"Ordinary
Paragraph">，L<verbatim|/"Verbatim Paragraph">，L<command|/"Command
Paragraph">。



=head2 Ordinary Paragraph X<POD, ordinary paragraph>

Pod
中大部分的段落属于普通的文本块。你可以简单的将你的文字不加任何标记的输入到这种段落中，当该段文字格式化输出时，文档会自动调整到合适的格式。

你也可以在 ordinary paragraphs
中使用如下标记符号：B<bold>，I<italic>，C<code-style>，L<hyperlinks|perlfaq>等等。这些格式化符号将会在
"L<Formatting Codes|/"Formatting Codes"> 中介绍。



=head2 Verbatim Paragraph X<POD, verbatim paragraph> X<verbatim>

Verbatim paragraphs
一般用来放置代码块，或是一些不需要格式化输出的文字。

verbatim paragraph
中每行第一个字符默认为空格或者制表符。其中制表符为8空格制表符。verbatim
paragraph 中没有特殊的转移符号，\ 就是 \
的意思，并没有其它含义。



=head2 Command Paragraph X<POD, command>

command paragraph
通常用来标识整块文本，所以一般用来放置标题或列表。

command paragraphs 默认以 "=" 开头。

    =pod
    =head1 Heading Text
    =head2 Heading Text
    =head3 Heading Text
    =head4 Heading Text
    =over identifier
    =item stuff
    =back    =begin format
    =end format
    =for format text...
    =encoding type
    =cut

下面详细的来介绍他们：

=over 

=item C<=head1 I<Heading Text>> X<=head1> X<=head2> X<=head3> X<=head4> X<head1>
X<head2> X<head3> X<head4>

=item C<=head2 I<Heading Text>>

=item C<=head3 I<Heading Text>>

=item C<=head4 I<Heading Text>>

Head1 到 Head4 用来制作标题，head1 等级最高。在 head
之后文字即为相应的标题。比如：

  =head2 Object Attributes

"Object Attributes" 为相应的标题。（需要注意的是 head3、head4
是最近被加入的，在一些旧版的 pod
解释器中可能无法使用。）标题中可以使用特殊的格式符号来格式化输出：

  =head2 Possible Values for C<$/>

格式化符号将在 "L<Formatting Codes|/"Formatting Codes"> 中讲述。

=item C<=over I<indentlevel>> X<=over> X<=item> X<=back> X<over> X<item> X<back>

=item C<=item I<stuff...>>

=item C<=back>

Item，over，和 back 需要在这里解释下："=over"
指定缩进级别，之后经常用来放置 "=item"
或者一段需要特殊缩进的文字。另外在 item
的最后，需要用 "=back" 来结束。over
之后跟缩进级别，默认下是4空格。在 item
中你可以用格式化符号来格式化输出，如：

  =item Using C<$|> to Control Buffering

格式化符号将在 "L<Formatting Codes|/"Formatting Codes"> 中讲述。

"=over" ... "=back" 也有一些简单的规则：

=over 

=item *

"=item" 不要用在 "=over" ... 和 "=back" 外面。

=item *

在 "=over" 之后应该是一个 "=item"，尽管没有 item 存在在
"=over" ... "=back" 中间。

=item *

"=headI<n>" 不要放在 "=over" ... 和 "=back" 中间。

=item *

更重要的是，要保持项目一致：不要用 "=item *"，而是用
"=item 1."，"=item 2."，等。或者用 "=item foo"，"=item bar"等。

如果你使用符号或编号来定义
item，那么请坚持这么做，pod 解释器会根据第一个 "=item"
的类型来决定如何输出这个列表。

=back

=item C<=cut> X<=cut> X<cut>

使用空行，"=cut"，空行的形式来结束一个 pod 块。

=item C<=pod> X<=pod> X<pod>

"=pod" 不做任何事情，它只是一个 pod
的标记，一般用来标记你的 pod 从何处开始。

  =item stuff()

  this function does stuff.

  =cut

  sub stuff {
    ...
  }

  =pod

  Remember to check its return value, as in:

    stuff() || die "Couldn't do stuff!";

  =cut

=item C<=begin I<formatname>> X<=begin> X<=end> X<=for> X<begin> X<end> X<for>

=item C<=end I<formatname>>

=item C<=for I<formatname> I<text...>>

For，begin，end 可以使你传递特定的 formatter
来解释输出得到 text/code/data。

"=begin I<formatname>" 到 "=end I<formatname>" 中间的内容将有
I<formatname> 来解释输出。

  =begin html

  <hr> <img src="thang.png">
  <p> This is a raw HTML paragraph </p>

  =end html

"=for I<formatname> I<text...>" 指明只有 text 会被 formatname
来解释输出，不会影响 pod 的其他部分。

  =for html <hr> <img src="thang.png">
  <p> This is a raw HTML paragraph </p>

This means the same thing as the above "=begin html" ... "=end html" region.

That is, with "=for", you can have only one paragraph's worth of text (i.e.,
the text in "=foo targetname text..."), but with "=begin targetname"
... "=end targetname", you can have any amount of stuff inbetween.  (Note
that there still must be a blank line after the "=begin" command and a blank
line before the "=end" command.

这里有几个简单的例子：

  =begin html

  <br>Figure 1.<br><IMG SRC="figure1.png"><br>

  =end html

  =begin text

    ---------------
    |  foo        |
    |        bar  |
    ---------------

  ^^^^ Figure 1. ^^^^

  =end text

一些常用的 formatter
有："roff"，"man"，"latex"，"tex"，"text"，"html" 等。

"comment" formatter 是注释，将不会出现在解释后的 pod 中。

  =for comment
  Make sure that all the available options are documented!

有些 formatter 需要前导冒号。如，"=begin :formatname" ... "=end
:formatname"。

=item C<=encoding I<encodingname>> X<=encoding> X<encoding>

这个命令用来指明 pod 的编码格式。

  =encoding utf8

  =encoding koi8-r
  
  =encoding ShiftJIS
  
  =encoding big5

=back

C<=endoing> 影响整个文档，所以只声明一次就可以了。

还有需要注意的是，一个命令作用在它的段落，而不是某一行。在后面的例子中，你可以看到每个段落中间都有空行来标识。

一些例子：

  =over

  =item *

  First item

  =item *

  Second item

  =back

  =over

  =item Foo()

  Description of Foo function

  =item Bar()

  Description of Bar function

  =back



=head2 Formatting Codes X<POD, formatting code> X<formatting code> X<POD, interior
sequence> X<interior sequence>

有很多格式化符号可以用在 ordinary paragraphs 或 command
paragraphs 中。

=for comment "interior sequences" is such an opaque term.  Prefer "formatting
codes" instead.

=over 

=item C<IE<lt>textE<gt>> -- italic text X<I> X<< IZ<><> >> X<POD, formatting code,
italic> X<italic>

用于语句中的强调（"C<be
IE<lt>careful!E<gt>>"）或是表示参数（"C<redo IE<lt>LABELE<gt>>"）

=item C<BE<lt>textE<gt>> -- bold text X<B> X<< BZ<><> >> X<POD, formatting code,
bold> X<bold>

用在命令中的选项（"C<perl's BE<lt>-nE<gt>
switch>"），语句中的强调（"C<some systems provide a BE<lt>chfnE<gt>
for that>"），（"C<and that feature is known as
BE<lt>autovivificationE<ft>>"）。

=item C<CE<lt>codeE<gt>> -- code text X<C> X<< CZ<><> >> X<POD, formatting code,
code> X<code>

用在表示代码的文本（"C<CE<lt>gmtime($^T)E<gt>>"），或是表示代码的输出结果（"C<CE<lt>drwxr-xr-xE<gt>>"）。

=item C<LE<lt>nameE<gt>> -- a hyperlink X<L> X<< LZ<><> >> X<POD, formatting code,
hyperlink> X<hyperlink>

这个命令有很多用法。这条命令中的
C<text>，C<name>，C<section> 中不能出现 '/' 和 '|'，而且 '<' 和
'>' 需要成对出现。

=over 

=item *

C<LE<lt>nameE<gt>>

链接到 Perl manual page（如: C<LE<lt>Net::PingE<gt>>）。C<name>
中不能包含空格。这个命令也可以链接到 Unix man pages，如
C<LE<lt>crontab(5)E<gt>>。

=item *

C<LE<lt>name/"sec"E<gt>> 或 C<LE<lt>name/secE<gt>>

链接到文档的某章节，如 C<LE<lt>perlsyn/"For Loops"E<gt>>。

=item *

C<LE<lt>/"sec"E<gt>> 或 C<LE<lt>/secE<gt>>

链接到本文档的某章节，如 C<LE<lt>/"Object Methods"E<gt>>。

=back

pod 中的章节是由 head 或 item 来指定的。比如，
C<LE<lt>perlvar/$.E<gt>> 或 C<LE<lt>perlvar/"$."E<gt>> 都会链接到
perlvar 中的 "C<=item $.>"上。C<LE<lt>perlsyn/For LoopsE<gt>> 或
C<LE<lt>perlsyn/"For Loops"E<gt>> 都会链接到 perlsyn 中的 "C<=head2
For Loops>" 上。

要想控制显示什么内容，可以通过 "C<LE<lt>text|...E<gt>>"
来实现。

=over 

=item *

C<LE<lt>text|nameE<gt>>

链接到某文档，如 C<LE<lt>Perl Error Messages|perldiagE<gt>>。

=item *

C<LE<lt>text|name/"sec"E<gt>> 或 C<LE<lt>text|name/secE<gt>>

链接到文档的某一章节，如 C<LE<lt>postfix "if"|perlsyn/"Statement
Modifiers"E<gt>>。

=item *

C<LE<lt>text|/"sec"E<gt>>，C<LE<lt>text|/secE<gt>> 或
C<LE<lt>text|"sec"E<gt>>

链接到本文档的某一章节，如 C<LE<lt>the various
attributes|/"Member Data"E<gt>>。

=back

或者你也可以链接到一个网页：

=over 

=item *

C<LE<lt>scheme:...E<gt>>

C<LE<lt>text|scheme:...E<gt>>

链接到一个网页的绝对地址。如，C<LE<lt>http://www.perl.org/E<gt>>
或 C<LE<lt>The Perl Home Page|http://www.perl.org/E<gt>>。

=back

=item C<EE<lt>escapeE<gt>> -- a character escape X<E> X<< EZ<><> >> X<POD,
formatting code, escape> X<escape>

和 HTML/XML 中的转义十分相似。

=over 

=item *

C<EE<lt>ltE<gt>> -- < (less than)

=item *

C<EE<lt>gtE<gt>> -- > (greater than)

=item *

C<EE<lt>verbarE<gt>> -- | (I<ver>tical I<bar>)

=item *

C<EE<lt>solE<gt>> = a literal / (I<sol>idus)

The above four are optional except in other formatting codes, notably
C<LE<lt>...E<gt>>, and when preceded by a capital letter.

=item *

C<EE<lt>htmlnameE<gt>>

用于一些非数字的 HTML 标记。

=item *

C<EE<lt>numberE<gt>>

"0x" 表示十六进制数，"0" 表示为八进制数。

旧的 pod 解释器可能无法识别八进制数和十六进制数。

=back

=item C<FE<lt>filenameE<gt>> -- 表示文件名 X<F> X<< FZ<><> >> X<POD,
formatting code, filename> X<filename>

通常用斜体表示，如 "C<FE<lt>.cshrcE<gt>>"。

=item C<SE<lt>textE<gt>> -- 不断行的文本 X<S> X<< SZ<><> >> X<POD,
formatting code, non-breaking space> X<non-breaking space>

如：S<C<SE<lt>$x ? $y : $zE<gt>>>。

=item C<XE<lt>topic nameE<gt>> -- 索引条目 X<X> X<< XZ<><> >> X<POD,
formatting code, index entry> X<index entry>

有些解释器会忽略它，不过有的会用它来建立索引条目。它总是呈现为空字符串，如
C<XE<lt>absolutizing relative URLsE<gt>>。

=item C<ZE<lt>E<gt>> -- 空格式化代码 X<Z> X<< ZZ<><> >> X<POD, formatting
code, null> X<null>

这个不经常用到。如： "NE<lt>3" 可以用 "NZE<lt>E<gt>E<lt>3>"
来表示。

=for comment This was formerly explained as a "zero-width character".  But it in
most parser models, it parses to nothing at all, as opposed to parsing as if
it were a E<zwnj> or E<zwj>, which are REAL zero-width characters.  So
"width" and "character" are exactly the wrong words.

=back

大部分时候当你需要使用 '<' 或 '>' 的时候，你需要使用
C<E> 来转义输出。

    C<$a E<lt>=E<gt> $b>

这将会得到："C<$a E<lt>=E<gt> $b>"。

一种更加友好的方式就是使用 '<<' 或 '>>'
来进行输出，这样里面的 '<' 和 '>' 就不需要进行转义了。

    C<< $a <=> $b >>

实际上，你可以用任意数量的反复尖括号，只要保证与内容有空格间隔即可。

    C<<< $a <=> $b >>>
    C<<<<  $a <=> $b     >>>>

它们都表示一个意思。

    C<$a E<lt>=E<gt> $b>

The multiple-bracket form does not affect the interpretation of the contents
of the formatting code, only how it must end.  That means that the examples
above are also exactly the same as this:

    C<< $a E<lt>=E<gt> $b >>

另外一个用法就是当你想得到 C<C> (code style) 的时候

    open(X, ">>thing.dat") || die $!
    $foo->bar();

你可以这样写：

    C<<< open(X, ">>thing.dat") || die $! >>>
    C<< $foo->bar(); >>

这比旧方法更容易被阅读。旧方法书写如下：

    C<open(X, "E<gt>E<gt>thing.dat") || die $!>
    C<$foo-E<gt>bar();>

这个功能目前被 pod2text（Pod::Text)，pod2man（Pod::Man），或
pod2xxx or Pod:Xxxx等使用 Pod::Parser 1.093 、 Pod::Tree 1.02
以后的解释器所支持。

=head2 The Intent X<POD, intent of>

Pod 的目的是使用，而不贪图一些华而不实的功能。

The Pod format is not necessarily sufficient for writing a book.  Pod is
just meant to be an idiot-proof common source for nroff, HTML, TeX, and
other markup languages, as used for online documentation.  Translators exist
for B<pod2text>, B<pod2html>, B<pod2man> (that's for nroff(1) and troff(1)),
B<pod2latex>, and B<pod2fm>.  Various others are available in CPAN.



=head2 Embedding Pods in Perl Modules X<POD, embedding>

你可以在脚本中内嵌入 Pod
文档。如果想要在脚本的结束加入 pod，你可以使用 __END__
或 __DATA__ 来标记，记得要在 pod
与上面的标记中间加入空行。

  __END__

  =head1 NAME

  Time::Local - efficiently compute time from local and GMT time

如果在标记与 "=head1"
中间没有空行分割的话，许多解释器将无法正确的识别。

=head2 提示

=over 

=item * X<podchecker> X<POD, validating>

B<podchecker> 命令会检查你的 pod
是否包含错误并给出适当的警告。

=item *

如果你对书写 HTML 比书写 pod
更加熟悉，你也可以通过书写简单的 HTML 并通过
L<Pod::HTML2Pod|Pod::HTML2Pod> 来转化成 Pod。

=item *

许多旧的解释器要求在每条命令的结尾都要有 "=cut"
命令。

 # - - - - - - - - - - - -
 =item $firecracker->boom()

 This noisily detonates the firecracker object.
 =cut
 sub boom {
 ...

... 将会使的 pod 解释器无法解释该文档。

你应该这样做：

 # - - - - - - - - - - - -

 =item $firecracker->boom()

 This noisily detonates the firecracker object.

 =cut

 sub boom {
 ...

=item *

旧的解释器需要有严格的空行分割。如果你没有做到的话，就不能正常解释输出。

=item *

Older translators might add wording around an LE<lt>E<gt> link, so that
C<LE<lt>Foo::BarE<gt>> may become "the Foo::Bar manpage", for example.  So
you shouldn't write things like C<the LE<lt>fooE<gt> documentation>, if you
want the translated document to read sensibly.  Instead, write C<the
LE<lt>Foo::Bar|Foo::BarE<gt> documentation> or C<LE<lt>the Foo::Bar
documentation|Foo::BarE<gt>>, to control how the link comes out.

=item *

Going past the 70th column in a verbatim block might be ungracefully wrapped
by some formatters.

=back

=head1 备注

查阅一下模块获得更多信息，L<perlpodspec>，L<perlsyn/"PODs:
Embedded
Documentation">，L<perlnewmod>，L<perldoc>，L<pod2html>，L<pod2man>，L<podchecker>。

=head1 作者

Larry Wall, Sean M. Burke译者：xiaomo(wxm4ever@gmail.com)

</pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/oct/blog/2011/12/25/%5BMoose%3A%3AManual%5DMoose%3A%3AManual%3A%3AAttributes./">[Moose::Manual]Moose::Manual::Attributes.</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-25T17:30:00+08:00" pubdate data-updated="true">Dec 25<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><pre lang="perl">

        *****************************************************
        *           GENERATED FILE, DO NOT EDIT             * 
        * THIS IS NO SOURCE FILE, BUT RESULT OF COMPILATION *
        *****************************************************

This file was generated by po4a(7). Do not store it (in VCS, for example),
but store the PO file used as source file by po4a-translate. 

In fact, consider this as a binary, and the PO file as a regular .c file:
If the PO get lost, keeping this translation up-to-date will be harder.

=pod

=head1 NAME

Moose::Manual::Attributes - Moose 对象的属性

=head1 VERSION

version 2.0401

=head1 介绍

Moose
中最强大也最灵活的功能莫过于对象的属性。通过简单的声明属性便可以构造一个功能强大的类。

类的每一个成员都是一个属性。比如，C<Person> 类有 first
name 和 last name。属性对于类是可选的，好比并不是每一个
C<Person> 类都有社保号。

我们可以把类属性当作是成员的名字，通过这个名字我们可以读取或设置该成员的值。当然，属性还可以包括默认值、类型约束、委托方法等等。

在其他语言中，属性也被称为 slots 或 properties。

=head1 属性设置

通过 C<has> 来声明一个属性：

  package Person;

  use Moose;

  has 'first_name' => ( is => 'rw' );

这样就声明了有一个可读写的属性的类 C<Person>。

=head2 读写 vs 只读

通过 C<has>
传递的选项可以对属性进行相关设置。不过最简单也是最基本的是，你可以通过
C<is> 来设置变量的读取权限，read-only(ro) 或者
read-write(rw)。当设置为rw
时，你可以通过访问器来修改它的值。但设置为
ro时，你便只能读取该属性的值。

事实上，你可以不设置 C<is>，Moose
会默认使该属性没有任何存取权限。这对某些属性比较管用，如句柄等。但是
Moose
会抛出警告以防止程序员忘记书写存取规则。如果你确实需要这么做，那么可以通过设置
C<is> 为 C<bare> 来防止产生警告。

=head2 存取方法

每个属性有一个或多个存取方法，通过存取方法，你可以读取或者设置该属性的值

默认的存取方法和属性的名字一样。如果属性存取权限设置为
rw，则可以通过存取方法来读写属性值，反之，则不可以。

以上面的 C<Person> 类为例，我们有一个存取方法为
C<first_name>，通过这个存取方法我们可以读取或设置
C<Person> 实例的 C<first_name> 属性。

如果你愿意的话，你也可以指定具体的方法来进行存取操作。这对于你想要设置一个默认存取权限为
ro，但是可以通过某种方法来修改属性是非常方便的。

  has 'weight' => (
      is     => 'ro',
      writer => '_set_weight',
  );

这在以下场景中是非常方便的。比如，每当我们调用 C<eat>
方法的时候，我们可能会改变
weight，而在其他场景中我们对 weight 只有读取权限。

有些人喜欢把读取和设置方法分别来声明。在 I<Perl Best
Practices> 中，Damian
Conway也推荐读者使用"get_"和"set_"类方法。

我们可以通过具体的声明来做到。

  has 'weight' => (
      is     => 'rw',
      reader => 'get_weight',
      writer => 'set_weight',
  );

你认为这样一遍又一遍非常繁琐？你说的对，不过幸运的是，Moose
提供了相当强大的拓展系统，可以让你覆盖默认的命名约定。有关详细信息，请参阅
L<Moose::Manual::MooseX>。

=head2 断言和清理方法

Moose 允许你使用断言来判断一个属性是否已经被定义。

断言方法可以告诉你当前属性是否被定义。不过需要注意的是，当属性被设置为
C<undef>或者其他的一些假值，断言依然会返回 true。

清理方法会取消设置属性。这和设置属性为 C<undef> 是
I<不同的>。清理函数是为了让你更方便的使用断言。

这里有一个例子用来讲解断言和清理方法。

  package Person;

  use Moose;

  has 'ssn' => (
      is        => 'rw',
      clearer   => 'clear_ssn',
      predicate => 'has_ssn',
  );

  ...

  my $person = Person->new();
  $person->has_ssn; # false

  $person->ssn(undef);
  $person->ssn; # returns undef
  $person->has_ssn; # true

  $person->clear_ssn;
  $person->ssn; # returns undef
  $person->has_ssn; # false

  $person->ssn('123-45-6789');
  $person->ssn; # returns '123-45-6789'
  $person->has_ssn; # true

  my $person2 = Person->new( ssn => '111-22-3333');
  $person2->has_ssn; # true

默认情况下，Moose
不为你提供断言和清理方法。当你具体指明时，Moose
会为你提供的。

=head2 必需？

默认情况下，所有的属性都是可选的，不需要在构造对象的时候就明确给出。如果你想指明某个属性是必须的，你可以把
C<required> 属性设置为 true。

  has 'name' => (
      is       => 'ro',
      required => 1,

值得一提的是，什么时候才是"required"。

基本上，当这个属性名必须被提供给构造函数，或者通过
default、builder来设置，这种情况下是 required。

如果你在一个必须属性上定义了清理方法，这个清理方法是I<可以>运行的，也就是说一个必须属性也是可以被取消设置的。

但是这样做大多是没有意义的，所以我们并不推荐这么做。

=head2 默认值和构造方法

属性可以设置默认值，而且 Moose
提供了两种方法来设置默认值。

最简单的，你可以通过 C<default> 来设置。

  has 'size' => (
      is        => 'ro',
      default   => 'medium',
      predicate => 'has_size',
  );

如果 size 属性没有提供给构造函数，那么 size
属性会被设置为默认值 C<medium>：

  my $person = Person->new();
  $person->size; # medium
  $person->has_size; # true

你也可以通过提供一个子函数来提供默认值。

  has 'size' => (
      is => 'ro',
      default =>
          sub { ( 'small', 'medium', 'large' )[ int( rand 3 ) ] },
      predicate => 'has_size',
  );

这是一个简单的例子。每次初始化构建默认值的时候，子函数便会被调用。

当你提供子函数引用时，Moose
会调用它，并且不传递任何参数进去。

  has 'size' => (
      is      => 'ro',
      default => sub {
          my $self = shift;

          return $self->height > 200 ? 'large' : 'average';
      },
  );

C<default>
是在构造函数中开始运行的，所以会比一些属性更先运行。但当
C<default>依赖其他属性时就会出现一些问题。不过你可以通过设置属性为
C<lazy> 来解决。这个会在之后讲到。

如果你想在 default
中使用引用的话，这个引用必须在子函数中返回。

  has 'mapping' => (
      is      => 'ro',
      default => sub { {} },
  );

这是必要的。否则 Perl
会实例化一次，然后该引用在各个实例中被共享。下面这个是错误的。

  has 'mapping' => (
      is      => 'ro',
      default => {}, # wrong!
  );

如果你赋给 default 一个非子函数返回的引用时，Moose
会抛出一个错误。

If Moose allowed this then the default mapping attribute could easily end up
shared across many objects. Instead, wrap it in a subroutine reference as we
saw above.

这有一点古怪，不过请原谅，Perl 有时候就是这样。

你可以通过 C<builder> 方法来避开这一古怪的现象。

  has 'size' => (
      is        => 'ro',
      builder   => '_build_size',
      predicate => 'has_size',
  );

  sub _build_size {
      return ( 'small', 'medium', 'large' )[ int( rand 3 ) ];
  }

这个使用有以下几个好处。把对属性的操作移到一个代码块中，方便阅读与组织。这样子使用的话，也方便子类重载或者由一个
role 来实现。

我们强烈建议你使用 C<builder> 来初始化属性。它就是
C<default> 的增强版。

C<builder> 和 C<default>
作为类方法调用的，不接受额外的参数。

=head3 Builders 覆写

C<builder> 是通过名字来指定初始化函数的。所以 builder
方法是可以被继承和重载的。

比如我们继承 C<Person> 类，我们便可以重载 C<_build_size>：

  package Lilliputian;

  use Moose;
  extends 'Person';

  sub _build_size { return 'small' }

=head3 Builders 与 roles 配合工作

同样，builders 可以与 roles
完美的配合。比如，一个角色可以为一个类提供
builder方法。

  package HasSize;
  use Moose::Role;

  requires '_build_size';

  has 'size' => (
      is      => 'ro',
      lazy    => 1,
      builder => '_build_size',
  );

  package Lilliputian;
  use Moose;

  with 'HasSize';

  sub _build_size { return 'small' }

关于 Roles 的更多信息可以查阅 L<Moose::Manual::Roles>。

=head2 Laziness

Moose 允许你通过 C<lazy> 来推迟属性定义。

  has 'size' => (
      is      => 'ro',
      lazy    => 1,
      builder => '_build_size',
  );

当某属性 C<lazy> 为 true 时，该属性的 default
并不会在构造实例时运行，而是在相应的访问器访问时才进行计算。为什么要这样做呢？

首先，如果该属性的 default
值依赖于其他属性，那么该属性的 C<lazy> I<必须>为 true。

有一些情况下是不需要在该属性被请求前进行计算的。通过设置该属性为
C<lazy>，你可以有效的节省你的 CPU 时间。

我们建议你使用 builder 或者 lazy default。

=head2 构造函数的参数（C<init_arg>）

默认情况下，每个属性都可以通过名字传递给类。有时，你可能需要用一个略有不同的名字，或者你不想传递任何参数进去。

你可以通过 C<init_arg> 选项来做到以上的事情。

  has 'bigness' => (
      is       => 'ro',
      init_arg => 'size',
  );

现在我们有一个"bigness"属性，但是我们通过 C<size>
来传递到构造函数中。

你也可以通过如下方式设置不接受任何参数。

  has '_genetic_code' => (
      is       => 'ro',
      lazy     => 1,
      builder  => '_build_genetic_code',
      init_arg => undef,
  );

By setting the C<init_arg> to C<undef>, we make it impossible to set this
attribute when creating a new object.

=head2 循环引用

Moose 内置是支持 weak reference 的，可以通过设置 C<weak_ref>
为 true 来实现。

  has 'parent' => (
      is       => 'rw',
      weak_ref => 1,
  );

  $node->parent($parent_node);

这对你构建一个包含循环引用的类是非常有用的。

When the object in a weak references goes out of scope, the attribute's
value will become C<undef> "behind the scenes". This is done by the Perl
interpreter directly, so Moose does not see this change. This means that
triggers don't fire, coercions aren't applied, etc.

该属性并没有被清楚，所以在调用断言方法时，仍然返回
true。（这里有点含糊不清，具体的请见原文档）

=head2 触发器

C<trigger> 将在属性被设置的时候自动被调用。

  has 'size' => (
      is      => 'rw',
      trigger => \&_size_set,
  );

  sub _size_set {
      my ( $self, $size, $old_size ) = @_;

      my $msg = $self->name;

      if ( @_ > 2 ) {
          $msg .= " - old size was $old_size";
      }

      $msg .= " -size is now $size";
      warn $msg;
  }

当属性被设置之后，触发器将会被调用。Moose
会传递新值、旧值进去，当没有旧值时，旧值参数为
C<undef>。

这个与 C<after>
方法修饰符是有区别的。触发器只在属性被设置时被调用，而不是每当访问器访问时触发。触发器也会在构造函数运行时被调用。而
C<after> 方法修饰符不是。

注意，触发器不在 C<default> 或 C<builder> 之后被调用。

=head2 属性类型

属性类型可以限制只接受某些类型的值：

  has 'first_name' => (
      is  => 'ro',
      isa => 'Str',
  );

这表明 C<first_name> 属性是字符串类型。

Moose
还提供了一个快捷的方法来指定一个属性的类型，就是通过一个
role 来实现的。

  has 'weapon' => (
      is   => 'rw',
      does => 'MyApp::Weapon',
  );

关于属性类型的信息具体请查阅 L<Moose::Manual::Types>。

=head2 委托属性

Moose 可以定义委托属性来操作属性值。

  has 'hair_color' => (
      is      => 'ro',
      isa     => 'Graphics::Color::RGB',
      handles => { hair_color_hex => 'as_hex_string' },
  );

当调用 C<hair_color_hex> 时，会实际上调用
C<<$self->hair_color->as_hex_string>>。

关于委托属性的更多信息请查阅 L<Moose::Manual::Delegation>。

=head2 属性特征和元类

Moose 最好的特点就是可以通过 traits 和 元类来实现自省。

你可以提供一个或多个 traits 来描述一个属性：

  use MooseX::MetaDescription;

  has 'size' => (
      is          => 'ro',
      traits      => ['MooseX::MetaDescription::Meta::Trait'],
      description => {
          html_widget  => 'text_input',
          serialize_as => 'element',
      },
  );

你可以很方便的使用一个或多个 traits。

关于属性特征和元类的许多模块都可以在 CPAN
上找到。你可以在L<Moose::Manual::MooseX>
中找到一些示例。关于"元类"和"继承"的更多信息请查阅
L<Moose::Cookbook>。

=head2 定义自己的委托属性

Native delegations 允许你定义 Perl 的数据结构。

比如，我们可以创建关于数组引用的
C<push()>，C<shift()>，C<map()>，C<count()>等方法。

  has 'options' => (
      traits  => ['Array'],
      is      => 'ro',
      isa     => 'ArrayRef[Str]',
      default => sub { [] },
      handles => {
          all_options    => 'elements',
          add_option     => 'push',
          map_option     => 'map',
          option_count   => 'count',
          sorted_options => 'sort',
      },
  );

更多信息请查阅 L<Moose::Manual::Delegation>。

=head1 属性继承

默认情况下，子类可以继承父类中所有的属性。你也可以在子类中重载它们。

继承一个属性，只需要简单的在前面加(C<+>)：

  package LazyPerson;

  use Moose;

  extends 'Person';

  has '+first_name' => (
      lazy    => 1,
      default => 'Bill',
  );

现在子类中的 C<first_name> 属性是 lazy 的，而且默认值为
C<'Bill'>。

我们建议你在不是很了解的时候不要随便使用，尤其是涉及到类型（C<isa>）的时候。

=head1 多属性快捷创建

如果你有大量的属性仅仅是名字不同，你可以一次性的声明它们。

  package Point;

  use Moose;

  has [ 'x', 'y' ] => ( is => 'ro', isa => 'Int' );

因为 C<has>
也是一个函数，所以你也可以通过循环来创建。

  for my $name ( qw( x y ) ) {
      my $builder = '_build_' . $name;
      has $name => ( is => 'ro', isa => 'Int', builder => $builder );
  }

=head1 更多

Moose 属性是一个 big
topic，而这个文档只包含了一部分。我们建议你继续阅读L<Moose::Manual::Delegation>
和 L<Moose::Manual::Types> 来更全面的了解属性。

=head1 更多的选项信息

Moose
属性有许多选项。下面列出一些你可能会比较感兴趣的。

=head2 C<文档描述>

你可以为你的属性提供一个文档描述。

  has 'first_name' => (
      is            => 'rw',
      documentation => q{The person's first (personal) name},
  );

Moose 会把该描述存储起来。

=head2 C<序列化数据>

如果你的属性是一段数组引用或者 hash 引用，C<auto_deref>
这个设置会让 reader
来访问这个属性时，可以看到序列化以后的内容：

  my %map = $object->mapping;

当然这仅仅在你的属性是 C<ArrayRef> 或者 C<HashRef> 时有用。

我们推荐你查阅 L<Moose::Meta::Attribute::Native>
来得到更多信息。

=head2 初始化

Moose 提供一个选项叫做
C<initializer>。这个会在构造函数中改变属性值。

=head1 作者

Moose
是由许多志愿者共同努力的结果。具体的请参看L<Moose/CABAL>
和 L<Moose/CONTRIBUTORS>译者：xiaomo(wxm4ever@gmail.com)

=head1 版权和许可

This software is copyright (c) 2011 by Infinity Interactive, Inc..

这是自由软件，您可以重新分配或者根据 Perl 5
的编程语言系统本身相关的条款进行修改。

</pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/oct/blog/2011/12/23/%5BMoose%3A%3AManual%5DMoose%3A%3AManual%3A%3AClasses/">[Moose::Manual]Moose::Manual::Classes</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-23T08:49:00+08:00" pubdate data-updated="true">Dec 23<span>rd</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本来是计划一周翻译一篇的.我知道这个计划有点慢.但是凡事需要按着计划来.今天去看扶凯的日志.发现他又更新了Moose::Manual的文章.恩.看他的翻译学到了好多技巧.不管Moose::Manual这个翻译是不是无用功了.自己做好就好.</p>

<pre lang="perl">

        *****************************************************
        *           GENERATED FILE, DO NOT EDIT             * 
        * THIS IS NO SOURCE FILE, BUT RESULT OF COMPILATION *
        *****************************************************

This file was generated by po4a(7). Do not store it (in VCS, for example),
but store the PO file used as source file by po4a-translate. 

In fact, consider this as a binary, and the PO file as a regular .c file:
If the PO get lost, keeping this translation up-to-date will be harder.

=pod

=head1 NAME

Moose::Manual::Classes - 用 Moose 来构建类

=head1 VERSION

version 2.0401

=head1 使用 Moose

用 Moose 来构建类是非常简单的，你只需要简单的 C<use
Moose>:

  package Person;

  use Moose;

通过 Moose 构造一个类就是这么简单。

整个过程在实验上还是很麻烦的，不过就让我们跳过它吧。

当你加载 L<Moose> 的时候，大量的 Moose
语法糖便引入到你定义的类中，比如C<extends>，C<has>，C<with>
等等。这些语法糖可以方便的帮助你创建你的类。比如，你可以这样定义一个属性
...

  package Person;

  use Moose;

  has 'ssn' => ( is => 'rw' );

在 L<Moose::Manual::Attributes>
中我们会详细的介绍类的属性如何在 Moose 中表示。

另外，加载 Moose 也会打开 C<strict> 和 C<warnings> 信息。

加载 Moose 之后你的类便成为 L<Moose::Object>
的子类。L<Moose::Object>
有默认的构造函数、析构函数和一些辅助方法，具体的信息你可以在
L<Moose::Manual::Construction>中找到。

为了方便，Moose
根据你新定义的类，产生了一种新的变量类型。关于 Moose
类型这方面的内容，你可以在 L<Moose::Manual::Types> 中找到。

Moose 同样也会为你的类创建一个 L<Moose::Meta::Class>
。这个元类会在你的实例调用C<meta>
方法时返回。具体示例请见 C<< Person->meta >>。

产生元类为你提供了良好的自省 API 。它也被 Moose
用来实现一些功能，如添加一个属性，声明父类等。事实上，所有
Moose 提供的语法糖都是基于对元类的操作来完成的。

=head1 子类

Moose 提供一个简单的语法糖 C<extends>
来方便你声明当前类的父类。

  package User;

  use Moose;

  extends 'Person';

  has 'username' => ( is => 'rw' );

需要注意的是，每次当你调用 C<extends> 时，Moose
会I<重置>其父类。当你需要多继承的时候，请一次性的提供其要继承的父类，如
C<extends 'Foo', 'Bar'> 。

你可以用 Moose 来继承一个非 Moose
类。当你这么做的时候，父类的构造函数会自动执行，就像自动调用了
C<new>
似的。这种情况下，你将不得不自己考虑好各个属性的初始化。与此许多
Moose 中非常神奇方便的方法你也不能使用了。

如果你想要继承非 Moose 类，你可以去 CPAN 查看
L<MooseX::NonMoose> 来了解更多信息。

=head1 清理 Moose 带来的垃圾

当你使用 Moose 构建类的时候，Moose
会为你引入大量的语法糖函数。我们建议在你的程序中移除这些多余的不必要的方法。

有很多方法来清理 Moose 带来的垃圾。我们推荐使用
L<namespace::autoclean>。这个模块不仅会清理 Moose
带来的垃圾，也会清理其他来源的垃圾的。

  package Person;

  use namespace::autoclean;

  use Moose;

如果你不想使用额外的模块的话，你可以在类的结尾处使用
C<no Moose> 。

  package Person;

  use Moose;

  has 'ssn' => ( is => 'rw' );

  no Moose;

=head1 更快些

Moose 有一个功能叫做
"immutabilization"，这个功能可以使你的类在运行的时候更快。当你把一个类
immutable，也就是告诉 Moose 你今后将不再改变这个类。

这样的话，Moose 会为你生成一段特殊的代码，比如"inline"
constructor。

要使类 immutable，你只需要通过元类来调用 C<make_immutable>
方法。

  __PACKAGE__->meta->make_immutable;

=head2 Immutabilization 和 C<new()>

如果你重载了 C<new()> 方法，那么 immutabilization
将不能加速你的代码。你应该通过C<BUILD()>
方法来实现重载的部分，因为 C<BUILD()> 方法是在inline
constructor之后调用的。

如果你非要自己提供一个不同的 C<new()>
方法的话，你必须自己提供一个
immutabilization的方法，而且需要继承 Moose
的元类，当然，这些内容已经超出本手册的范围了。

=head1 作者

Moose 是由许多志愿者共同努力的结果。具体的请参看
L<Moose/CABAL> 和L<Moose/CONTRIBUTORS>译者：xiaomo(wxm4ever@gmail.com)

=head1 版权和许可

This software is copyright (c) 2011 by Infinity Interactive, Inc..

这是自由软件，您可以重新分配或者根据 Perl 5
的编程语言系统本身相关的条款进行修改。
</pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/oct/blog/2011/12/21/%5BMoose%3A%3AManual%5D+Moose%3A%3AManual%3A%3AConceptes%E7%BF%BB%E8%AF%91/">[Moose::Manual] Moose::Manual::Conceptes翻译</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-21T05:21:00+08:00" pubdate data-updated="true">Dec 21<span>st</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>更新完这个。下周再继续。这周的课程设计比较费事啊。</p>

<pre lang="perl">

        *****************************************************
        *           GENERATED FILE, DO NOT EDIT             * 
        * THIS IS NO SOURCE FILE, BUT RESULT OF COMPILATION *
        *****************************************************

This file was generated by po4a(7). Do not store it (in VCS, for example),
but store the PO file used as source file by po4a-translate. 

In fact, consider this as a binary, and the PO file as a regular .c file:
If the PO get lost, keeping this translation up-to-date will be harder.

=encoding UTF-8

=pod

=head1 NAME

Moose::Manual::Concepts - Moose 关于面向对象的一些概念

=head1 VERSION

version 2.0401

=head1 Moose 与 Perl 旧式面向对象的比较

以前你可能没有仔细的研究过 package 和 class 、 attributes 和 methods、 constructors 和 methods
等的区别。在 Moose 中，这些都是有各自的概念的，尽管它们都是基于普通的 Perl 实现的。

元对象协议(MOP)为面向对象中常用的概念提供了良好的自省功能，而 Moose 则提供语法糖。Moose
也引进了一些新的概念，比如角色（roles）,方法修饰符（method modifiers）和委托属性（declarative delegation）。

知道如何用 Moose 来表示这些概念，并且和旧式的 Perl 实现进行对比，这是一个比较推荐的学习方式。

=head2 Class

当你在 package 里使用 "use Moose"，这表明你在定义一个类。一个简单的类包括属性和方法。当然它也可以包含角色、方法修饰符等等。

一个类I<有>零个或零个以上的B<属性>。

一个类I<有>零个或零个以上的B<方法>。

一个类I<有>零个或零个以上的父类。它继承它所有的父类。

一个类I<有>零个或零个以上的B<方法修饰符>。这些修饰符可以作用于自己的方法或者是从父类继承过来的方法。

一个类I<能>充当零个或零个以上的B<角色>。

一个类I<有>一个B<构造函数>和一个B<析构函数>。Moose 为你默认提供。

B<构造函数>接受相应的命名参数并用它们来初始化B<对象的实例>。

一个类I<有>一个B<元类>，同时也就有B<元类属性>，B<元类方法>，B<元类角色>。这个元类I<描述>着这个类。

一个类通常是一个类别的或相似类别的名字，如"People"、"Users"。

  package Person;

  use Moose;
  # now it's a Moose class!

=head2 Attribute

属性是来定义它的类的属性。它I<总有>一个名称，它I<可能>还具有一些其他属性。

这些属性可以包含读/写标志，B<类型>信息，访问器方法，B<委托方法>，默认值等等。

属性不是方法。而是要创建各种存取方法的原因。至少，一个正常的属性将有一个读者的访问方法。许多属性有其他方法，如一个写者的方法，一个清空方法，一个测试方法（如这个属性被设置了吗？）等等。

属性也可以定义B<委托属性>，这会根据委托属性的映射关系来产生额外的方法。

默认情况下，Moose 在类的实例中以哈希表的方式存储属性，但是这个过程对程序员是I<不可见>的。最好通过明确定义的存取方法来访问这些"不透明"的属性。

属性是类的成员。比如，People 有 first name 和 last name， User 有 password 和上次登录的datetime。

  has 'first_name' => (
      is  => 'rw',
      isa => 'Str',
  );

=head2 Method

在类中定义的子函数就是类的方法。

方法对应的行为，就是你的对象要做的事情。比如，一个 User 可以登录。

  sub login { ... }

=head2 Role

角色是用来定义类所扮演的角色。比如，Machine 类和 Bone 类都具有不易碎等特性。所以，角色就是用来定义一些跨多个不相关的类的共同特性的。

一个角色I<有>零个或零个以上的B<属性>。

一个角色I<有>零个或零个以上的B<方法>。

一个角色I<有>零个或零个以上的B<方法修饰符>。

一个角色I<有>零个或零个以上的B<所需方法>（required methods）。

所需方法不是在角色中详细定义的。所需方法是所要充当该角色的类所必须重载的方法。

一个角色I<有>零个或零个以上的B<排除角色>（excluded roles）。

排除角色是表明充当该角色的类不能同时充当的角色。

当一个类充当一个角色时，角色的属性和方法成为类的属性和方法。（这里不好翻译）。

角色就好像其他面向对象的语言中的接口这一概念。

  package Breakable;

  use Moose::Role;

  requires 'break';

  has 'is_broken' => (
      is  => 'rw',
      isa => 'Bool',
  );

  after 'break' => sub {
      my $self = shift;

      $self->is_broken(1);
  };

=head2 Method modifiers

B<方法修饰符>是在一个特定的函数被执行时的一个钩子。比如，你可以这样定义一个方法修饰符，"在执行C<login()>前，先执行这段代码"。常用的修饰符有"before"，"after"，"around"，"augment"。你可以对一个方法绑定多个方法修饰符。

方法修饰符经常用来重载父类中的方法。方法修饰符经常出现在角色中。

本质上，方法修饰符就是普通的 Perl 程序在命名方法之前或之后调用。

  before 'login' => sub {
      my $self = shift;
      my $pw   = shift;

      warn "Called login() with $pw\n";
  };

=head2 Type

Moose 有一个（微型）的类型系统。这允许你为属性定义类型。Moose 根据 Perl 的变量类型有内置类型，如
C<Str>，C<Num>，C<Bool>，C<HashRef>，等等。

此外，在你应用程序中的每一个类的名称也可以是一种类型。

当然，你也可以定义有自己的约束的类型。如，你可以定义正数 C<PosInt> 类型。

=head2 Delegation

Moose 可以定义委托属性。委托属性会根据相应的映射来调用正确的方法。

=head2 Constructor

构造函数为类构建B<实例>。在旧式的 Perl 语言中，这通常通过调用 C<new()> 来返回一个 C<bless> 后的引用。

在 Moose 中，C<new()>已经为你做好了所有的事情。你从来不需要自己定义相应的构造函数。

有些时候你想在实例初始化的时候做一些事情，你可以通过定义 C<BUILD()> 方法来实现，Moose 会在构建实例的时候自动为你调用。

=head2 Destructor

当你的对象实例超出范围的时候，这个方法将会自动执行。你可以指定这个方法在结束时做什么，不过这通常是不必要的。

在旧式的 Perl 中，这个是 C<DESTORY()> 方法，但在 Moose 中，这个是 C<DEMOLISH()> 方法。

=head2 Object instance

对象的实例由B<构造函数>创建。如，Person 或者 User，由它们的B<constructor>来构建的。

实例有类的属性。如，person 有 first name 和 last name。

在旧式的 Perl 5 中，这通常通过被绑定的哈希引用来表示。在 Moose 中，你不需要知道实例的结构具体是什么样子（虽然也是通过哈希引用来实现的）。

=head2 总结

=over 4

=item * Class

旧式 Perl OO 中，类是一个没有自省机制以及各种符号表的包。

在 Moose 中，有良好的自省机制和定义格式。

=item * Attributes

旧式 Perl OO 中，需要手写存取方法，定义一堆符号表，或者使用一些辅助模块如 C<Class::Accessor>。

在 Moose 中，这些都是声明好的定义，并且与方法不同。

=item * Method

这个与旧式的 Perl OO 大致相同。

=item * Roles

旧式 Perl OO 中，通过C<Class::Trait>、C<Class::Role>、或者C<mixin.pm>来实现？

在 Moose 中，它是 Moose 核心功能之一。

=item * Method Modifiers

旧式 Perl OO 中，可能能通过高深的符号表来实现，而且你可能从来都没见过类似的实现（至少在 Perl 5 以前没有见过）。

=item * Type

旧式 Perl OO 中，通过在C<new()>或者相应的访问函数中手动检查类型。

在 Moose 中，你声明变量类型，然后通过变量名来使用它们。

=item * Delegation

旧式 Perl OO 中，通过C<Class:Delegation>或C<Class::Delegator>，不过实现起来会比想象中还难。

在 Moose 中，通过简单的声明就可以。

=item * Constructor

旧式 Perl OO 中，通过调用负责C<bless>引用的C<new()>方法来实现。

在 Moose 中，已经默认为你实现。

=item * Destructor

旧式 Perl OO 中，通过定义C<DESTORY()>方法来实现。

在 Moose 中，通过定义C<DEMOLISH()>来实现。

=item * Object Instance

旧式 Perl OO 中，实例是一个已绑定的哈希引用。

在 Moose 中，这是一个有着一堆属性和方法的不透明的东西，不过你可以很方便的使用。

=item * Immutabilization

Moose 所谓的"immutabilization"的功能，指让你的类不可改变，之后由 Moose 来为你生成一些复杂难辨别的代码，以加快速度。

=back

=head1 什么是元类？

元类是用来描述类的类。在 Moose
中，每一个你定义的类都有一个C<meta()>方法。C<meta()>方法返回L<Moose::Meta::Class>实例，其中有一个自省API可以告诉你它代表的类。

  my $meta = User->meta();

  for my $attribute ( $meta->get_all_attributes ) {
      print $attribute->name(), "\n";

      if ( $attribute->has_type_constraint ) {
          print "  type: ", $attribute->type_constraint->name, "\n";
      }
  }

  for my $method ( $meta->get_all_methods ) {
      print $method->name, "\n";
  }

基本上每个我们之前所提到的概念都有元类，所以有L<Moose::Meta::Class>，L<Moose::Meta::Attribute>，L<Moose::Meta::Method>，L<Moose::Meta::Role>，L<Moose::Meta::TypeConstraint>，L<Moose::Meta::Instance>，等等。

=head1 BUT I NEED TO DO IT MY WAY!

Moose 最伟大的事情就是当你挖掘 Moose 的本质时，发现有些事情不是按你所想的进行，那么你可以通过扩展元类来修改。

许多这样的代码很短但是很令人惊讶，而且一旦你做过一次，你将永远不需要重复去做了，只需要简单的加载你的拓展就可以了。

  package MyWay::User;

  use Moose;
  use MooseX::StrictConstructor
  use MooseX::MyWay;

  has ...;

=head1 接下来做什么？

已经把 Moose 介绍给你了，接下来就该花时间来学习如何使用了。

如果你想要知道 Moose 是如何把你的代码用旧式 Perl 5 OO
来实现的，你可以查看L<Moose::Manual::Unsweetened>。这会帮助你快速的了解"the Moose way"的。

你也可以直接跳到L<Moose::Manual::Classes>来查看剩余的L<Moose::Manual>。

在那之后，我们推荐你继续看L<Moose::Cookbook>。这样之后，相信你会很熟悉 Moose 的工作原理以及一些相关面向对象的特性。

在那之后，如果你仍然感兴趣的话，继续看 the Meta and Extending 介绍，这对扩展 Moose 的人来说很有帮助。

=head1 作者

Moose 是由许多志愿者共同努力的结果。具体的请参看
L<Moose/CABAL>和L<Moose/CONTRIBUTORS>。译者:xiaomo(wxm4ever@gmail.com)

=head1 版权和许可

This software is copyright (c) 2011 by Infinity Interactive, Inc..

这是自由软件，您可以重新分配或者根据 Perl 5 的编程语言系统本身相同的条款进行修改。
</pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/oct/blog/2011/12/18/%5BMoose%3A%3AManual%5D%E8%AF%95%E7%BF%BB%E8%AF%91%E3%80%82/">[Moose::Manual]试翻译。</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-18T08:35:00+08:00" pubdate data-updated="true">Dec 18<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>恩。Moose是近期研究的目标，简单的应用也是可以的,OO用起来确实方便。不过还是想锻炼下自己，为以后做准备。虽然 @扶凯 那里有部分 Moose的翻译(完全版的Moose Cookbook.和部分转来的Moose Manual的翻译），我还是想把这个事情进行下去。
晚上实验室吃饭。就这样了。</p>

<pre lang="perl">
        *****************************************************
        *           GENERATED FILE, DO NOT EDIT             * 
        * THIS IS NO SOURCE FILE, BUT RESULT OF COMPILATION *
        *****************************************************

This file was generated by po4a(7). Do not store it (in VCS, for example),
but store the PO file used as source file by po4a-translate. 

In fact, consider this as a binary, and the PO file as a regular .c file:
If the PO get lost, keeping this translation up-to-date will be harder.

=encoding UTF-8

=pod

=head1 NAME

Moose::Manual - 什么是 Moose？

=head1 VERSION

version 2.0401

=head1 什么是 Moose?

Moose 是 Perl 5 中的一个完整的对象系统。和大多数面向对象的语言相同（ Perl5 不是严格面向对象的)， Moose
提供关键字去声明属性、构造对象、继承等等。这些关键字可能是语言的一部分，不过你不需要关心它们是怎么实现的。

实际上我们不能随意创建新的关键字，但是我们可以提供类似于"语法糖"的方式来使它们用起来更像是关键字。使用
Moose，你便可以自如地进行面向对象的编程，而不需要知道 Perl 中复杂的绑定引用、访问方法等知识。

Moose 可以让你把更多的精力集中在结构的逻辑实现上，而不是语言实现上。Moose 式的类定义更像是非常简明的英语句子。

Moose 是基于 C<Class::MOP> 构建的，MOP 是一种元对象协议。通过
MOP，我们可以通过一种简单明了的方式去访问对象的属性、父类、子类以及方法等。MOP 抽象了符号表，类似 C<@ISA>等符号，MOP
也抽象了我们所擅长的一些 Perl 的技巧。(The MOP abstracts away the symbol table, looking at
C<@ISA> vars, and all the other crufty Perl tricks we know and
love(?). 这里不会翻译。)

Moose 以 大部分 Perl 6 的面向对象为基础，并且借鉴了 CLOS、Smalltalk等许多面向对象的语言优秀想法。

=head1 为什么用 Moose?

Moose 使你在 Perl 5 既简单又强大的使用面向对象的技术。它封装了 Perl 5中复杂的高级 API，使得你可以方便的使用。

如果你想要拓展 Moose 的话，它内置的强大的自省 API 和扩展供你使用。

=head1 一个例子

  package Person;

  use Moose;

  has 'first_name' => (
      is  => 'rw',
      isa => 'Str',
  );

  has 'last_name' => (
      is  => 'rw',
      isa => 'Str',
  );

  no Moose;
  __PACKAGE__->meta->make_immutable;

这是一个完整的可用的类定义。

  package User;

  use DateTime;
  use Moose;

  extends 'Person';

  has 'password' => (
      is  => 'rw',
      isa => 'Str',
  );

  has 'last_login' => (
      is      => 'rw',
      isa     => 'DateTime',
      handles => { 'date_of_last_login' => 'date' },
  );

  sub login {
      my $self = shift;
      my $pw   = shift;

      return 0 if $pw ne $self->password;

      $self->last_login( DateTime->now() );

      return 1;
  }

  no Moose;
  __PACKAGE__->meta->make_immutable;

我们将在其他文档中看到具体的代码注释。通过上面的代码，我们可以初步领略到 Moose 面向对象编程的简单与强大。

=head1 目录

本手册包含如下文档。

=over 4

=item L<Moose::Manual::Concepts>

介绍 Moose 的一些概念，并且与旧式的 Perl 5 OO 进行了对比。

=item L<Moose::Manual::Unsweetened>

通过两个例子来对比 Perl 5 旧式 OO 的实现与 Moose 式实现。

=item L<Moose::Manual::Classes>

如何在自己的类中使用 Moose 以及如何继承 Moose 类。

=item L<Moose::Manual::Attributes>

介绍 Moose 面向对象系统中的一个核心部分 -----属性，以及 Moose 中与属性相关的一些特性。

=item L<Moose::Manual::Delegation>

介绍委托属性以及如何使用委托属性。

=item L<Moose::Manual::Construction>

介绍如何在 Moose 中构造对象以及销毁对象。

=item L<Moose::Manual::MethodModifiers>

介绍方法修饰符，可以让你在执行某个方法前先执行某段特定的代码，或者包装一个方法。

=item L<Moose::Manual::Roles>

介绍 Moose 中的角色。Moose 的角色是一种正交继承类的行为方式。

=item L<Moose::Manual::Types>

Moose 中的类型系统，让你严格的定义各个属性中可以包含什么类型的值。

=item L<Moose::Manual::MOP>

Moose 的元 API 系统，可以让你访问类的父类、子类、方法和属性等。

=item L<Moose::Manual::MooseX>

这个文档介绍几个很有用的 Moose 拓展。这些拓展可以在 CPAN 上得到。

=item L<Moose::Manual::BestPractices>

Moose 有很多特性，并且每个事情不只只有一个实现方式。不过我们认为，选取一些简单的例子以帮助用户更好的学习和使用 Moose。

=item L<Moose::Manual::FAQ>

Moose 常见的问题与回答。

=item L<Moose::Manual::Contributing>

Interested in hacking on Moose? Read this.

=item L<Moose::Manual::Delta>

这个文档详细的介绍了具体的向后不兼容性以及其他重要的变化。

=back

=head1 还是不明白为什么要用 Moose？

如果你仍然不明白“为什么我要用 Moose？“，那么这个章节是为你准备的。

=over 4

=item 另一个面向对象的系统？

是的，我们知道有非常多非常多的方式在 Perl 5中实现面向对象的技术，它们有着各种各样的实现。Moose 与它们不同的是，Moose 不是 Perl
5 的新的一个面向对象系统，相反的，它拓展了现有的 Perl 5 面向对象系统。

Moose 是以 Perl 5 的元类系统 L<Class::Mop>为基础构建的。这表明，Moose
不仅可以更好的实现面向对象，而且更能提供强大的元类编程。

=item 这是认真的吗，还是只是一个实验用品？

Moose 是B<基于> Stevan 的 Perl 6 meta-model
的实验测试，但是，MooseB<不是>一个实验用品，是可以供正常的生产使用的。

=item Moose 可以应用在生产环境中吗？

是的，完全没有问题。

Moose 已经被很多人、很多公司应用在很多成功的案例中。Moose 在生产环境中很少出现或者根本不出现问题。我们认为 Moose
是高度稳定的而且我们会一直致力于保持它的稳定。

当然，这一切需要你来实现。如果你有任何问题或疑虑，欢迎发送邮件给 Stevan、moose@perl.org 邮件列表，或者到
irc.perl.org#moose 询问。

=item Perl 5 中的 Moose 和 Perl 6 的面向对象是一样的吗？

不是。虽然 Moose 是收到 Perl 6 的启发，但是它本身并不在 Perl 6 中。相反，它是一个 Perl 5 中的面向对象的系统。Stevan
厌倦了在 Perl 5 中写枯燥复杂的旧式代码以及对 Perl 6 的面向对象非常感兴趣，所以他写了 Moose 而不是转向 Ruby 阵营。

=item Wait, I<post> modern, I thought it was just I<modern>?

Larry Wall 1999年的题为“Perl, the first postmodern computer
language“的演讲中说过他认为很酷的东西便把它加到 Perl 中，而没有用的东西就坚决不引入到 Perl 中。 Stevan 认同这个观点，所以
Moose 借来了 Perl 6 的面向对象系统，并且从
CLOS(LISP)，Smalltalk，Java，BETA，OCaml，Ruby等语言中借来了许多很酷的东西，而不是很喜欢的部分却一点都没有引入到
Moose 中。因此，有了现在的 Moose。

 

=back

=head1 作者

Moose 是由许多志愿者共同努力的结果。具体的请参看 L<Moose/CABAL>和L<Moose/CONTRIBUTORS>。
译者：xiaomo (wxm4ever@gmail.com)。

=head1 版权和许可

This software is copyright (c) 2011 by Infinity Interactive, Inc..

这是自由软件，您可以重新分配或者根据 Perl 5 的编程语言系统本身相同的条款进行修改。

</pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/oct/blog/2011/12/14/man+page%E9%AB%98%E4%BA%AE/">Man Page高亮</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-14T12:30:00+08:00" pubdate data-updated="true">Dec 14<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><pre lang="bash">
# vi ~/.bashrc
# 增加下面的内容：
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'

source ~/.bashrc
</pre>


<p><span class="label">没什么太大变化. 就是看着舒服.</span></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/oct/blog/2011/12/11/vim%E5%AF%BC%E5%85%A5%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">Vim导入外部配置文件</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-11T12:16:00+08:00" pubdate data-updated="true">Dec 11<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>如同bash一般.使用source命令.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/oct/blog/page/4/">&larr; Older</a>
    
    <a href="/oct/blog/archives">Blog Archives</a>
    
    <a class="next" href="/oct/blog/page/2/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/oct/blog/2012/06/11/emacs+auto-complete+plugins/">emacs auto-complete plugins</a>
      </li>
    
      <li class="post">
        <a href="/oct/blog/2012/06/09/LaTex+CJK+%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98%5BLinux%5D/">LaTex CJK 字体问题[Linux]</a>
      </li>
    
      <li class="post">
        <a href="/oct/blog/2012/06/08/nmap+%E4%BD%BF%E7%94%A8./">nmap 使用.</a>
      </li>
    
      <li class="post">
        <a href="/oct/blog/2012/06/07/Arch+PGP+xxx+unknown+%E8%A7%A3%E5%86%B3/">Arch PGP xxx unknown 解决</a>
      </li>
    
      <li class="post">
        <a href="/oct/blog/2012/06/04/Mongo+%E8%81%9A%E5%90%88/">Mongo 聚合</a>
      </li>
    
  </ul>
</section>





<section>
 <h1>Categories</h1>
 <ul id="categories">
 <li class='category'><a href='/oct/blog/categories/android开发/'>Android开发 (16)</a></li>
<li class='category'><a href='/oct/blog/categories/apache/'>Apache (6)</a></li>
<li class='category'><a href='/oct/blog/categories/django/'>Django (3)</a></li>
<li class='category'><a href='/oct/blog/categories/linux/'>Linux (38)</a></li>
<li class='category'><a href='/oct/blog/categories/lisp/'>Lisp (1)</a></li>
<li class='category'><a href='/oct/blog/categories/mapx开发/'>MapX开发 (3)</a></li>
<li class='category'><a href='/oct/blog/categories/mongo/'>Mongo (2)</a></li>
<li class='category'><a href='/oct/blog/categories/moose::manual::attributes/'>Moose::Manual::Attributes (1)</a></li>
<li class='category'><a href='/oct/blog/categories/moose::manual::classes/'>Moose::Manual::Classes (1)</a></li>
<li class='category'><a href='/oct/blog/categories/moose::manual::concepts/'>Moose::Manual::Concepts (1)</a></li>
<li class='category'><a href='/oct/blog/categories/mysql/'>MySQL (3)</a></li>
<li class='category'><a href='/oct/blog/categories/nginx/'>Nginx (2)</a></li>
<li class='category'><a href='/oct/blog/categories/php/'>PHP (30)</a></li>
<li class='category'><a href='/oct/blog/categories/perl/'>Perl (32)</a></li>
<li class='category'><a href='/oct/blog/categories/perldoc/'>PerlDoc (1)</a></li>
<li class='category'><a href='/oct/blog/categories/python/'>Python (42)</a></li>
<li class='category'><a href='/oct/blog/categories/wordpress/'>WordPress (1)</a></li>
<li class='category'><a href='/oct/blog/categories/keepalive/'>keepalive (1)</a></li>
<li class='category'><a href='/oct/blog/categories/linux查看系统状态/'>linux查看系统状态 (1)</a></li>
<li class='category'><a href='/oct/blog/categories/lisp/'>lisp (1)</a></li>
<li class='category'><a href='/oct/blog/categories/make/'>make (1)</a></li>
<li class='category'><a href='/oct/blog/categories/man高亮/'>man高亮 (1)</a></li>
<li class='category'><a href='/oct/blog/categories/moose/'>moose (1)</a></li>
<li class='category'><a href='/oct/blog/categories/pdf/'>pdf (1)</a></li>
<li class='category'><a href='/oct/blog/categories/perlpod/'>perlpod (1)</a></li>
<li class='category'><a href='/oct/blog/categories/pkill/'>pkill (1)</a></li>
<li class='category'><a href='/oct/blog/categories/server/'>server (1)</a></li>
<li class='category'><a href='/oct/blog/categories/skills/'>skills (1)</a></li>
<li class='category'><a href='/oct/blog/categories/sql/'>sql (1)</a></li>
<li class='category'><a href='/oct/blog/categories/ssh/'>ssh (2)</a></li>
<li class='category'><a href='/oct/blog/categories/svn/'>svn (1)</a></li>
<li class='category'><a href='/oct/blog/categories/ubuntu/'>ubuntu (2)</a></li>
<li class='category'><a href='/oct/blog/categories/wp摘要/'>wp摘要 (1)</a></li>
<li class='category'><a href='/oct/blog/categories/wp页面模版/'>wp页面模版 (1)</a></li>
<li class='category'><a href='/oct/blog/categories/乱七八糟/'>乱七八糟 (24)</a></li>
<li class='category'><a href='/oct/blog/categories/前端技术/'>前端技术 (8)</a></li>
<li class='category'><a href='/oct/blog/categories/回归/'>回归 (1)</a></li>
<li class='category'><a href='/oct/blog/categories/设计模式/'>设计模式 (1)</a></li>
<li class='category'><a href='/oct/blog/categories/集体智慧/'>集体智慧 (7)</a></li>

 </ul>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - wangxiaomo -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
